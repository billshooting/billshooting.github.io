<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>浏览器缓存和Service Worker</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="9ioy" id="浏览器缓存和service-worker">浏览器缓存和Service Worker</h1><p data-anchor-id="e7c4"><code>@billshooting</code> <code>2018-05-06</code> <code>字数 6175</code> <a href="https://github.com/billshooting" target="_blank"><code>Follow me on</code><i class="icon-github"></i></a> <br>
<code>BOM</code></p><hr><div class="md-section-divider"></div><h2 data-anchor-id="cezs" id="1-传统的http浏览器缓存策略"><strong>1. 传统的HTTP浏览器缓存策略</strong></h2><p data-anchor-id="jupa">在一个网页的生命周期中，开发者为了缩短用户打开页面的时间，通常会设置很多缓存。其中包括了：</p><ul data-anchor-id="67g5">
<li>浏览器缓存</li>
<li>代理服务器缓存（CDN缓存）</li>
<li>服务器缓存</li>
<li>数据库缓存</li>
</ul><p data-anchor-id="340m">等各种缓存。这些缓存大多数和前端没什么关系，也不由前端开发者控制，其中和前端较为密切的是<strong>浏览器缓存</strong>，但它本质上也是由服务器控制的。</p><p data-anchor-id="cyzi">在Service Worker还未问世之前，浏览器缓存主要是由HTTP缓存策略和浏览器内置的存储功能（cookie，Local Storage，Session Storage等）来提供。其中HTTP缓存由于是钦定的，根正苗红，浏览器支持的也很好，是最常用的浏览器缓存技术。而通过浏览器内置存储功能来实现缓存，相比之下就没那么高端大气上档次了。因为这种方式没个标准范式，虽说可以通过JS进行控制显得比HTTP缓存灵活，但效果嘛就只能依赖程序员的水平了，也没有个统一的轮子能用，所以这种方式也就是小打小闹，不成气候。</p><p data-anchor-id="0f3m">下面介绍一下HTTP缓存的一些用法：</p><ul data-anchor-id="8na0">
<li><strong>Expires头部</strong> <br>
早在HTTP协议被设计的时候，协议的起草者们就想到了缓存的事情，自然也有相应的功能，那就是<code>Expires</code>这个头部。每当浏览器请求时，服务器可以在相应的报文中附加这个<code>Expires</code>，它的典型值看起来是这样的:</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="muh9" style=""><ol class="linenums"><li class="L0"><code class="language-json"><span class="typ">Expires</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Tue</span><span class="pun">,</span><span class="pln"> </span><span class="lit">01</span><span class="pln"> </span><span class="typ">May</span><span class="pln"> </span><span class="lit">2018</span><span class="pln"> </span><span class="lit">11</span><span class="pun">:</span><span class="lit">37</span><span class="pun">:</span><span class="lit">06</span><span class="pln"> GMT</span></code></li></ol></pre><p data-anchor-id="284s">也就是在该资源在世界协调时<code>2018/05/01 11:37:06</code>才过期，我的请求时间是<code>2018/05/01 07:37:06</code>，所以就是这个资源在4小时之后过期，4小时之内对该资源的请求都直接使用缓存，除非你用<code>Ctrl+F5</code>刷新。但是呢，这种控制明显是不够精细的，这是个HTTP1.0协议中规定的头部。由于我们现在都用HTTP2.0都已经来了，HTTP1.1已经全面普及了，这玩意自然已经用的不多了。</p><ul data-anchor-id="f9lr">
<li><strong>Cache-Control头部</strong> <br>
<code>Expires</code>头部只能控制过期时间，万一请求的资源在过期时间之前就更新了，那就可能会出现显示或者功能问题。为此，HTTP协议再更新到1.1版本的时候，增加了一个新的头部<code>Cache-Control</code>并规定：如果同时存在<code>Cache-Control</code>和<code>Expires</code>则前者有效。它有以下常用的值可选：<code>public</code> <code>private</code> <code>max-age</code> <code>s-maxage</code> <code>no-cache</code> <code>no-store</code>等。一个典型的值看起来是以下这样：</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ozke" style=""><ol class="linenums"><li class="L0"><code class="language-json"><span class="typ">Cache</span><span class="pun">-</span><span class="typ">Control</span><span class="pun">:</span><span class="pln"> s</span><span class="pun">-</span><span class="pln">maxage</span><span class="pun">=</span><span class="lit">300</span><span class="pun">,</span><span class="pln"> public</span><span class="pun">,</span><span class="pln"> max</span><span class="pun">-</span><span class="pln">age</span><span class="pun">=</span><span class="lit">60</span></code></li></ol></pre><p data-anchor-id="dcty">为了更好的说明各个字段的意义，先说下浏览器请求资源的步骤：</p><ol data-anchor-id="t38l">
<li>判断请求是否命中缓存，如命中则执行步骤2；如没有则执行步骤3；</li>
<li>判断缓存是否过期，如没有则直接返回；如过期则执行步骤3，并带上缓存信息；</li>
<li>浏览器向服务器请求资源；</li>
<li>服务器判断缓存信息，如资源尚未更新，则返回<code>304</code>，如没有缓存信息或则资源已更新则返回<code>200</code>，并把资源返回。</li>
<li>浏览器根据响应头部决定要不要存储缓存（只有<code>no-store</code>时不存储缓存信息）。</li>
</ol><p data-anchor-id="c425"><code>s-maxage</code>表示共享缓存的时间，单位是s，也就是5分钟； <br>
<code>public</code>表示这是个共享缓存，可以被其他session使用； <br>
<code>max-age</code>意义与<code>s-maxage</code>差不多，只是它用于<code>private</code>的情形； <br>
<code>no-cache</code>这种策略下，浏览器会跳过步骤2，并带上缓存信息向服务器发起请求。 <br>
<code>no-store</code>这种策略下，浏览器会跳过步骤5，由于没有缓存信息，每次浏览器请求时都不会带上缓存信息，就像第一次请求一样（Ctrl+F5效果）。</p><ul data-anchor-id="2f5d">
<li><strong>Last-Modified/If-Modified-Since</strong> <br>
上面说了，浏览器在有缓存信息的情况下，会带上缓存信息发起请求，那这个信息是怎么来的？又是怎么带在Request的头部当中呢？ <br>
原来，服务器在响应请求时，除了返回<code>Cache-Control</code>头部外，还会返回一个<code>Last-Modified</code>头部，用于指定该资源的服务器更新时间。当该资源在浏览器端过期时（由<code>max-age</code>或者<code>no-cache</code>决定），浏览器会带上缓存信息去发起请求，这个信息就由Request中的<code>If-Modified-Since</code>指定，通常也就是上次Response中<code>Last-Modified</code>的值。典型值如下：</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="c51d" style=""><ol class="linenums"><li class="L0"><code><span class="com">//Response:</span></code></li><li class="L1"><code><span class="typ">Last</span><span class="pun">-</span><span class="typ">Modified</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Sat</span><span class="pun">,</span><span class="pln"> </span><span class="lit">01</span><span class="pln"> </span><span class="typ">Jan</span><span class="pln"> </span><span class="lit">2000</span><span class="pln"> </span><span class="lit">00</span><span class="pun">:</span><span class="lit">00</span><span class="pun">:</span><span class="lit">00</span><span class="pln"> GMT</span></code></li><li class="L2"><code><span class="com">//Request:</span></code></li><li class="L3"><code><span class="typ">If</span><span class="pun">-</span><span class="typ">Modified</span><span class="pun">-</span><span class="typ">Since</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Sat</span><span class="pun">,</span><span class="pln"> </span><span class="lit">01</span><span class="pln"> </span><span class="typ">Jan</span><span class="pln"> </span><span class="lit">2000</span><span class="pln"> </span><span class="lit">00</span><span class="pun">:</span><span class="lit">00</span><span class="pun">:</span><span class="lit">00</span><span class="pln"> GMT</span></code></li></ol></pre><ul data-anchor-id="xu5h">
<li>Etag/If-None-Match <br>
<code>Last-Modified/If-Modified-Since</code>提供的控制已经比较多了，但有些时候，开发者还是不满意，因为它们只能<strong>提供对资源时间的控制，并只有精确到秒级</strong>。如果有些资源变化非常快，或者有些资源定时生成，但内容却是一样的，这些情况下<code>Last-Modified/If-Modified-Since</code>就不是很适用。 <br>
为此，HTTP1.1规定了<code>Etag/If-None-Match</code>这两个头部，它们的用法和<code>Last-Modified/If-Modified-Since</code>完全相同，一个用于响应，一个用于请求。只不过<code>Etag</code>用的不是时间，而是服务器规定的一个标签（通常是<strong>资源内容、大小、时间的hash值</strong>）。这样服务器通过这个头部可以更加啊精确地控制资源的缓存策略。 <br>
同样的，由于这个头部控制更加精细， 所以它的优先级会高于<code>Last-Modified/If-Modified-Since</code>,就像<code>Cache-Control</code>高于<code>Expires</code>一样。</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="c1qm" id="2-service-worker的原理"><strong>2. Service Worker的原理</strong></h2><p data-anchor-id="pk6l">HTTP缓存已经足够强大了，那开发者还有什么不满意呢？后端的开发者自然没什么不满意，前端的开发者就要嘀咕了：“浏览器的事情，为什么要依赖于后端呢？后端就好好提供数据就行了，缓存这种事情我想自己控制”。确实有人这么尝试过，就是之前说的用Local Storage或者Session Storage来存储一些数据，但这种方法缺少很多关键的浏览器基础设施，比如异步存储、静态资源存储、URL匹配、请求拦截等功能。而Service Worker的出现填补了这些基础设施缺少的问题。</p><p data-anchor-id="20lx">需要指出的是，Service Worker并非专门为缓存而设计，它还可以解决Web应用推送、后台长计算等问题。能解决精细化缓存控制，实在是由于它的功能强大，因为它本质上就是一个全新的JavaScript线程，运行在与主Javascript线程不同的上下文。service worker线程被设计成完成异步，一些原本在主线程中的同步API，如<code>XMLHTTPRequest</code>和<code>localStorage</code>是不能在service worker中使用的。</p><p data-anchor-id="v1e8">主Javascript线程是负责DOM的线程，而service worker线程被设计成无法访问DOM。这是很自然的，一般从事过客户端开发的开发者都知道，只能有一个UI线程，否则整个UI的控制会出现不可预估的问题。而保证UI顺滑不卡顿的原则就是<strong>尽量不在UI线程做大量计算和同步IO处理</strong>。</p><ol data-anchor-id="6ao4">
<li>sw线程能够用来和服务器沟通数据（service worker的上下文内置了fetch和Push API）</li>
<li>能够用来进行大量复杂的运算而不影响UI响应。</li>
<li>它能拦截所有的请求（通过监听fetch事件，任何对网络资源的请求都会触发该事件），并内置了一个完全异步的存储系统（Caches属性，完全异步并能存储全部种类的网络资源），这是它能精细化控制缓存的关键。</li>
</ol><p data-anchor-id="6wkb">可以看出service worker功能非常强大，特别是拦击所有请求、充当代理服务器这个功能，是强大而危险的。所以为了这个功能不被别有用心的人利用，service worker必须运行在HTTPS的Origin中，同时localhost也被认为是安全的，可以用于调试开发使用。</p><div class="md-section-divider"></div><h2 data-anchor-id="tatl" id="3-service-worker的缓存"><strong>3. Service Worker的缓存</strong></h2><p data-anchor-id="gec2">如前所述，service worker如果用于缓存则关键在于<strong>监听Fetch事件</strong>和<strong>管理Cache资源</strong>，不过在使用它们之前，得先把service worker激活才行。而service worker的激活则要经过以下步骤：</p><ol data-anchor-id="jd8j">
<li>浏览器发现当前页面注册了service worker(通过<code>navigator.service.Worker.register('/sw.js')</code>)；</li>
<li>浏览器下载<code>sw.js</code>并执行，完成安装阶段；</li>
<li>service worker等待Origin中其他worker失效，然后完成激活阶段；</li>
<li>service worker生效，<strong>注意它的生效范围不是当前页面，而是整个Origin</strong>。但是只有是在<code>register()</code>成功之后打开的页面才受SW控制。所以执行注册脚本的页面通常需要重载一下，以便让SW获得完全的控制。</li>
</ol><p data-anchor-id="4qre">下图是整个service worker的生命流程： <br>
<img src="http://static.zybuluo.com/billshooting/6zrhdyubpevspfuznz40fp9t/sw%E7%94%9F%E5%91%BD%E6%B5%81%E7%A8%8B.png" alt="sw生命流程.png-38.4kB"></p><p data-anchor-id="5ad1">下面用一个简单的例子来介绍service worker如何控制缓存，通常它在<code>index.html</code>中被注册： <br>
<strong>代码清单：index.html</strong></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="6ns7" style=""><ol class="linenums"><li class="L0"><code class="language-html"><span class="dec">&lt;!DOCTYPE html&gt;</span></code></li><li class="L1"><code class="language-html"><span class="tag">&lt;html&gt;</span></code></li><li class="L2"><code class="language-html"><span class="pln">    </span><span class="tag">&lt;head&gt;</span></code></li><li class="L3"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;meta</span><span class="pln"> </span><span class="atn">charset</span><span class="pun">=</span><span class="atv">"UTF-8"</span><span class="tag">&gt;</span></code></li><li class="L4"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;link</span><span class="pln"> </span><span class="atn">href</span><span class="pun">=</span><span class="atv">"style/style-1.css"</span><span class="pln"> </span><span class="atn">rel</span><span class="pln">-</span><span class="atv">"stylesheet"</span><span class="tag">&gt;</span></code></li><li class="L5"><code class="language-html"><span class="pln">    </span><span class="tag">&lt;/head&gt;</span></code></li><li class="L6"><code class="language-html"><span class="pln">    </span><span class="tag">&lt;body&gt;</span></code></li><li class="L7"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;img</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"image/image-1.png"</span><span class="pln"> </span><span class="tag">/&gt;</span></code></li><li class="L8"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;script</span><span class="pln"> </span><span class="atn">async</span><span class="pln"> </span><span class="atn">src</span><span class="pun">=</span><span class="atv">"js/script-1.js"</span><span class="tag">&gt;&lt;/script&gt;</span></code></li><li class="L9"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;script&gt;</span></code></li><li class="L0"><code class="language-html"><span class="pln">            </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'serivceWorker'</span><span class="pln"> in navigator</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-html"><span class="pln">                navigator</span><span class="pun">.</span><span class="pln">serviceWorker</span><span class="pun">.</span><span class="kwd">register</span><span class="pun">(</span><span class="str">'/sw.js'</span><span class="pun">)</span></code></li><li class="L2"><code class="language-html"><span class="pln">                    </span><span class="pun">.</span><span class="pln">then</span><span class="pun">(</span><span class="pln">reg </span><span class="pun">=&gt;</span><span class="pln"> console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'Service worker registered successfully!'</span><span class="pun">))</span></code></li><li class="L3"><code class="language-html"><span class="pln">                    </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">err </span><span class="pun">=&gt;</span><span class="pln"> console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'Service worker failed to register!'</span><span class="pun">));</span></code></li><li class="L4"><code class="language-html"><span class="pln">            </span><span class="pun">}</span></code></li><li class="L5"><code class="language-html"><span class="pln">        </span><span class="tag">&lt;/script&gt;</span></code></li><li class="L6"><code class="language-html"><span class="pln">    </span><span class="tag">&lt;/body&gt;</span></code></li><li class="L7"><code class="language-html"><span class="tag">&lt;/html&gt;</span></code></li></ol></pre><p data-anchor-id="39fo">可以看到这个页面有4个资源<code>style-1.css</code> <code>image-1.png</code> <code>script-1.js</code>以及<code>sw.js</code>。当页面中JS执行到register方法时，浏览器下载<code>sw.js</code>并根据<code>sw.js</code>内容准备安装Service worker。 <br>
<strong>代码清单: sw.js</strong></p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="gh4r" style=""><ol class="linenums"><li class="L0"><code class="language-javascript"><span class="pln">let cacheName </span><span class="pun">=</span><span class="pln"> </span><span class="str">'indexCache'</span><span class="pun">;</span></code></li><li class="L1"><code class="language-javascript"><span class="pln">self</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'install'</span><span class="pun">,</span><span class="pln"> event </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-javascript"><span class="pln">    </span><span class="com">//waitUntil接受一个Promise，直到这个promise被resolve，安装阶段才算结束</span></code></li><li class="L3"><code class="language-javascript"><span class="pln">    event</span><span class="pun">.</span><span class="pln">waitUntil</span><span class="pun">(</span></code></li><li class="L4"><code class="language-javascript"><span class="pln">        caches</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">cacheName</span><span class="pun">)</span></code></li><li class="L5"><code class="language-javascript"><span class="pln">            </span><span class="pun">.</span><span class="pln">then</span><span class="pun">(</span><span class="pln">cache </span><span class="pun">=&gt;</span><span class="pln"> cacheAll</span><span class="pun">([</span><span class="str">'/style/style-1.css'</span><span class="pun">,</span></code></li><li class="L6"><code class="language-javascript"><span class="pln">                                     </span><span class="str">'/image/image-1.png'</span><span class="pun">,</span></code></li><li class="L7"><code class="language-javascript"><span class="pln">                                     </span><span class="str">'/script/script-1.js'</span><span class="pun">,</span></code></li><li class="L8"><code class="language-javascript"><span class="pln">                                    </span><span class="pun">]))</span></code></li><li class="L9"><code class="language-javascript"><span class="pln">                    </span><span class="pun">);</span></code></li><li class="L0"><code class="language-javascript"><span class="pun">});</span></code></li><li class="L1"><code class="language-javascript"></code></li><li class="L2"><code class="language-javascript"><span class="com">//监听activate事件，可以在这个事件里情况上个sw缓存的内容</span></code></li><li class="L3"><code class="language-javascript"><span class="pln">self</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'activate'</span><span class="pun">,</span><span class="pln"> event </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">...}</span></code></li><li class="L4"><code class="language-javascript"></code></li><li class="L5"><code class="language-javascript"><span class="com">//监听fetch事件，可以拦截所有请求并处理</span></code></li><li class="L6"><code class="language-javascript"><span class="pln">self</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'fetch'</span><span class="pun">,</span><span class="pln"> event </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L7"><code class="language-javascript"><span class="pln">    event</span><span class="pun">.</span><span class="pln">respondWith</span><span class="pun">(</span></code></li><li class="L8"><code class="language-javascript"><span class="pln">        caches</span><span class="pun">.</span><span class="pln">match</span><span class="pun">(</span><span class="pln">event</span><span class="pun">.</span><span class="pln">request</span><span class="pun">)</span></code></li><li class="L9"><code class="language-javascript"><span class="pln">            </span><span class="pun">.</span><span class="pln">then</span><span class="pun">(</span><span class="pln">res </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L0"><code class="language-javascript"><span class="pln">                </span><span class="com">//1. 如果请求的资源已被缓存，则直接返回</span></code></li><li class="L1"><code class="language-javascript"><span class="pln">                </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">res</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> res</span><span class="pun">;</span></code></li><li class="L2"><code class="language-javascript"><span class="pln">                </span><span class="com">//2. 没有，则发起请求并缓存结果</span></code></li><li class="L3"><code class="language-javascript"><span class="pln">                let requestClone </span><span class="pun">=</span><span class="pln"> event</span><span class="pun">.</span><span class="pln">request</span><span class="pun">.</span><span class="pln">clone</span><span class="pun">();</span></code></li><li class="L4"><code class="language-javascript"><span class="pln">                </span><span class="kwd">return</span><span class="pln"> fetch</span><span class="pun">(</span><span class="pln">requestClone</span><span class="pun">).</span><span class="pln">then</span><span class="pun">(</span><span class="pln">netRes </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L5"><code class="language-javascript"><span class="pln">                    </span><span class="kwd">if</span><span class="pun">(!</span><span class="pln">netRes </span><span class="pun">||</span><span class="pln"> netRes</span><span class="pun">.</span><span class="pln">status </span><span class="pun">!==</span><span class="pln"> </span><span class="lit">200</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> netRes</span><span class="pun">;</span></code></li><li class="L6"><code class="language-javascript"><span class="pln">                    let responseClone </span><span class="pun">=</span><span class="pln"> netRes</span><span class="pun">.</span><span class="pln">clone</span><span class="pun">();</span></code></li><li class="L7"><code class="language-javascript"><span class="pln">                    caches</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">cacheName</span><span class="pun">).</span><span class="pln">then</span><span class="pun">(</span><span class="pln">cache </span><span class="pun">=&gt;</span><span class="pln"> cache</span><span class="pun">.</span><span class="pln">put</span><span class="pun">(</span><span class="pln">requestClone</span><span class="pun">,</span><span class="pln"> responseClone</span><span class="pun">));</span></code></li><li class="L8"><code class="language-javascript"><span class="pln">                    </span><span class="kwd">return</span><span class="pln"> netRes</span><span class="pun">;</span></code></li><li class="L9"><code class="language-javascript"><span class="pln">                </span><span class="pun">});</span></code></li><li class="L0"><code class="language-javascript"><span class="pln">            </span><span class="pun">})</span></code></li><li class="L1"><code class="language-javascript"><span class="pln">    </span><span class="pun">);</span></code></li><li class="L2"><code class="language-javascript"><span class="pun">});</span></code></li></ol></pre><p data-anchor-id="2wip">可以看到，service worker在安装时就缓存了三个资源文件，如果下次该Origin下有页面对这三个资源发起请求，则会被Fetch事件拦截，然后直接用缓存返回。如果对其他资源发起请求，则会使用网络资源作为响应，并把这些资源再次存储起来。</p><p data-anchor-id="myg1">可以看到仅用几十行代码就完成了一个非常强大的缓存控制功能，你还可以对特定的几个资源做自己的处理，取决你想怎么控制你的资源。目前还有一个问题尚待解决，那就是<strong>如果资源更新了，缓存该怎么办？</strong>目前有两种方法可以做到：</p><ol data-anchor-id="hwc1">
<li>更新<code>sw.js</code>文件，一旦浏览器发现安装使用的<code>sw.js</code>是不同的（通过计算hash值），浏览器就会重新安装service worker，你可以在安装激活的过程中清空之前的缓存，这样浏览器就会使用服务器上最新的资源。</li>
<li>对资源文件进行版本控制，就像我上面的例子一样你可以用<code>style-2.css</code>来代替<code>style-1.css</code>，这样service worker就会使用新的资源并缓存它。当然版本号不应该这么简单，最好是使用文件的<strong>内容+修改时间+大小</strong>的hash值来作为版本号。</li>
</ol><p data-anchor-id="iybu">以上两种方法都是可靠的，第一种方法的可靠性由浏览器保证，第二种方法则是已经久经考验，目前大多数网站的静态资源更新策略都是用的类似于第二种方法的<strong>版本控制</strong>。这两种方法通常会混在一起使用，因为你在调整资源的版本号的时候，必须要更新<code>sw.js</code>中资源列表，导致<code>sw.js</code>文件本身就修改。</p><p data-anchor-id="qwxw">还有个问题需要注意，<strong>那就是<code>sw.js</code>本身也会被HTTP缓存策略缓存</strong>。通过对<code>sw.js</code>文件名进行版本控制，可以避免因为service worker安装文件被缓存而导致资源更新不及时的问题。</p><div class="md-section-divider"></div><h2 data-anchor-id="4kws" id="4-service-worker的缓存延伸应用"><strong>4. Service Worker的缓存延伸应用</strong></h2><p data-anchor-id="h9xc">前面说过，service worker的出现并不是单纯的为解决<strong>精细化控制</strong>浏览器缓存问题的。它能充当代理服务器这一能力（通过拦截所有请求实现），能够实现HTTP缓存无法实现的功能:<strong>离线应用</strong>。因为在HTTP缓存策略下，如果一个资源过了服务器规定的到期时间，则必须要发起请求，一旦网络连接有问题，整个网站就会出现功能问题。而在service worker控制下的缓存，能够在代码中发现网络连接问题并直接返回缓存的资源。这种方式返回的响应对于浏览器来说是透明的，它会认为该响应就是服务器发送回来的资源。</p><p data-anchor-id="85ul">借助于上述能力以及service worker带来的推送能力，基于Web的应用已经能够媲美原生应用了。谷歌将这种Web应用称为PWA（Progressive Web Application）。</p><p data-anchor-id="ukws">随着Web应用的功能越来越强大，安卓和IOS上套壳应用越来越多，最近微软也宣布win 10 上UWP应用可以采用PWA模式开发。至此跨平台应用开发的主流技术变得越来越清晰起来，业界在经历了Java-SWT，QT，Xamarin的尝试之后，HTML+CSS+Javascript这套始于浏览器的技术，已经成为跨平台应用开发的主流技术。</p></div>
</body>
</html>