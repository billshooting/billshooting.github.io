<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>Javascript的事件模型和Promise实现</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="9ane" id="javascript的事件模型和promise实现">Javascript的事件模型和Promise实现</h1><p data-anchor-id="vzm4"><code>@bill_shooting</code> <code>2018-04-20</code> <code>字数 2291</code> <a href="https://github.com/billshooting" target="_blank"><code>Follow me on</code><i class="icon-github"></i></a> <br>
<code>javascript</code></p><hr><p data-anchor-id="1hru"><strong>1. Javascript的运行时模型——事件循环</strong> <br>
JS的运行时是个单线程的运行时，它不像其他编程语言，比如C++，Java，C#这些可以进行多线程操作的语言。当它执行一个函数时，它只会一条路走到黑，不会在当前函数结束之前去调用其他的函数（除非当前函数主动调用其他函数）。它也不用担心会有其他线程打扰它，因为它的运行时只有一个线程。如果你还记得一些计算机原理的话，这种运行时只有一个栈，设计起来相当的简单。</p><p data-anchor-id="5yjk">一条路走到黑的设计很棒，因为它足够简单，但是又是谁决定哪个函数从开始进入栈内执行呢？答案是JS的运行时还有一个<strong>事件等待队列</strong>与栈搭配，每当运行栈为空时（也就是当前函数运行结束），JS的运行时就从当前的事件队列中取出一个消息处理，执行与这个消息相关联的函数。这种行为可以用以下代码来说明：</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="e0dq" style=""><ol class="linenums"><li class="L0"><code class="language-Javascript"><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">eventQueue</span><span class="pun">.</span><span class="pln">waitForMessage</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-Javascript"><span class="pln">    </span><span class="kwd">let</span><span class="pln"> </span><span class="kwd">event</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> eventQueue</span><span class="pun">.</span><span class="pln">pop</span><span class="pun">();</span></code></li><li class="L2"><code class="language-Javascript"><span class="pln">    </span><span class="kwd">let</span><span class="pln"> handler </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">handler</span><span class="pun">;</span></code></li><li class="L3"><code class="language-Javascript"><span class="pln">    handler</span><span class="pun">();</span><span class="pln">                      </span><span class="com">//执行事件关联的函数</span></code></li><li class="L4"><code class="language-Javascript"><span class="pln">    context</span><span class="pun">.</span><span class="pln">scheduler</span><span class="pun">.</span><span class="pln">schedule</span><span class="pun">();</span><span class="pln">   </span><span class="com">//让调度器处理一下其他事务</span></code></li><li class="L5"><code class="language-Javascript"><span class="pun">}</span></code></li></ol></pre><p data-anchor-id="i4ca">有了运行栈和事件队列之后，我们的Javascript运行时已经初具雏形。不过Javascript中的变量都是对象，它们的大小通常很大，可不是一个小小的栈能放下的，如果我们熟悉C++，就会知道一般在C++中我们只在栈中存储基本类型（int, bool等）和指针，而指针所指的位置是内存堆中的一个地址，这也是JS的对象的存储地点。下面这张图可以形象地解释一下JS运行时的模型。 <br>
<img src="https://developer.mozilla.org/files/4617/default.svg" alt="JS的事件循环模型" title=""></p><p data-anchor-id="q0e1"><strong>2. 事件循环模型的优点和缺点</strong> <br>
<strong>先说优点</strong>。除了实现上的简单，Javascript的最大优点就是<strong>完全异步，永不阻塞</strong>。这句话可能有点令人迷糊，一个单线程的运行时怎么完全异步，永不阻塞？实际上虽然JS运行时单线程，但是浏览器是个多进程多线程的环境，这一个点在后端也一样，虽然Node是个单线程JS运行时，但是后端还有其他进程和线程配合Node一起完成响应操作。</p><p data-anchor-id="tvvr">以浏览器打开IndexedDB为例，当你执行<code>indexedDB.open()</code>的之后，当前的Javascript运行栈就结束了，JS可以处理其他事件的关联函数，所以JS不会阻塞。那原来的open操作交给谁了呢？浏览器会调用其他线程接管这个打开数据库的过程，当返回时，浏览器会在JS运行时的事件队列中添加一个<code>打开成功</code>或者<code>打开失败</code>的事件，同时将你当时添加的回调函数关联到事件。</p><p data-anchor-id="v81o"><strong>再说缺点</strong>。我们都知道JS的调用函数只会一条路走到黑，而且没有正常的方法能打断这一过程，如果这一路恰好比较长（比如进行了大量的数学运算），就会使JS进入一种<strong>类阻塞</strong>的状态，页面会无法响应。等等！刚说JS永不阻塞，这里怎么又冒出一个类阻塞呢？这时因为我们所说的阻塞一般都是指<strong>IO阻塞</strong>，也就是CPU等IO结束的过程，这种情况在JS中<strong>可以</strong>永远不会发生（注意这里是可以，不是一定，某些IO操作是有同步的API可以调用的）。所谓类阻塞状态呢，就是在执行CPU密集型任务，这是一种不可避免的过程。那为什么这种情况下页面会没有响应呢？这时因为浏览器虽然会把事件放入事件队列里，但是由于前一个函数还没执行完，页面响应事件关联的函数得不到执行，自然页面会表现出不响应的状态。</p><p data-anchor-id="6kd7"><strong>3. Promise的实现</strong> <br>
Promise是JS处理回调的一种方式，也是利用JS的事件循环模型的一个编程范式包装，也是ES7中<code>await</code> <code>async</code>的基础，下面给个例子来说明它和JS事件模型的联系。</p><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="7nus" style=""><ol class="linenums"><li class="L0"><code class="language-JavaScript"><span class="kwd">let</span><span class="pln"> getUrlAsync </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">url</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-JavaScript"><span class="pln">    </span><span class="kwd">let</span><span class="pln"> promise </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Promise</span><span class="pun">((</span><span class="pln">resolve</span><span class="pun">,</span><span class="pln"> reject</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-JavaScript"><span class="pln">        </span><span class="kwd">const</span><span class="pln"> xhr </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">XMLHttpRequest</span><span class="pun">();</span></code></li><li class="L3"><code class="language-JavaScript"><span class="pln">        xhr</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="str">'GET'</span><span class="pun">,</span><span class="pln"> url</span><span class="pun">);</span></code></li><li class="L4"><code class="language-JavaScript"><span class="pln">        xhr</span><span class="pun">.</span><span class="pln">onload </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> resolve</span><span class="pun">(</span><span class="pln">xhr</span><span class="pun">.</span><span class="pln">responseText</span><span class="pun">);</span></code></li><li class="L5"><code class="language-JavaScript"><span class="pln">        xhr</span><span class="pun">.</span><span class="pln">onerror </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> reject</span><span class="pun">(</span><span class="pln">xhr</span><span class="pun">.</span><span class="pln">statusText</span><span class="pun">);</span></code></li><li class="L6"><code class="language-JavaScript"><span class="pln">    </span><span class="pun">});</span></code></li><li class="L7"><code class="language-JavaScript"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> promise</span><span class="pun">;</span></code></li><li class="L8"><code class="language-JavaScript"><span class="pun">};</span></code></li><li class="L9"><code class="language-JavaScript"></code></li><li class="L0"><code class="language-JavaScript"><span class="pln">getUrlAsync</span><span class="pun">(</span><span class="str">'http://exaple.com/text/11111'</span><span class="pun">)</span></code></li><li class="L1"><code class="language-JavaScript"><span class="pln">    </span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">res </span><span class="pun">=&gt;</span><span class="pln"> console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">res</span><span class="pun">))</span></code></li><li class="L2"><code class="language-JavaScript"><span class="pln">    </span><span class="pun">.</span><span class="kwd">catch</span><span class="pun">(</span><span class="pln">error </span><span class="pun">=&gt;</span><span class="pln"> console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">error</span><span class="pun">));</span></code></li></ol></pre><p data-anchor-id="jcx0">当调用<code>getUrlAsync</code>时，JS运行时做以下事情： <br>
1. 会创建一个<code>Promise</code>对象，此时还是在<code>getUrlAsync</code>的栈帧里； <br>
2. 然后创建一个<code>XMLHttpRequest</code>对象，此时还是在<code>getUrlAsync</code>的栈帧里； <br>
3. 调用<code>XMLHttpRequest</code>的<code>open</code>方法，此时浏览器其他线程接管open过程，JS无需等待open结束； <br>
4. 给<code>xhr</code>的<code>onload</code>事件关联一个处理函数(委托），注意此时该事件并没有进入事件队列； <br>
5. 给<code>xhr</code>的<code>onerror</code>事件关联一个处理函数(委托），同样此时该事件没有进入运行时的事件队列； <br>
6. 传入<code>res =&gt; console.log(res)</code>来具体化第4步中的委托； <br>
7. 传入<code>error =&gt; console.log(error)</code>来具体化第5部中的委托，<strong>此时当前的运行栈就退出了，运行时将处理其他事件</strong>。 <br>
在某一个时刻，浏览器控制的open方法返回，它会在JS运行时的事件队列中添加一个事件，比如<code>onload</code> <br>
8. JS运行时循环到<code>onload</code>事件，并找到它的关联处理函数，并运行这个函数。</p></div>
</body>
</html>